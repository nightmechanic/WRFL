/*
 * "Main" file for WRFL project
 * WRFL by Ran Katz (Nightmechanic) is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
 * Based on a work at https://github.com/nightmechanic/WRFL.
 * main.c
 */



#include "Nokia5110.h"
#include "platform.h"
#include "wrfl_proto_mux.h"
#include "gears_logo.h"
#include "Kalman_AltiUno.h"

#include <stdbool.h>
#include <stdint.h>
#include <math.h>

#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_ints.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom.h"
#include "driverlib/ssi.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "sensorlib/hw_bmp180.h"
#include "sensorlib/i2cm_drv.h"
#include "sensorlib/bmp180.h"
#include "driverlib/rom_map.h"






//*****************************************************************************
//
// Define BMP180 I2C Address.
//
//*****************************************************************************
#define BMP180_I2C_ADDRESS  0x77



//*****************************************************************************
//
// Global instance structure for the I2C master driver.
//
//*****************************************************************************
tI2CMInstance g_sI2CInst;

//*****************************************************************************
//
// Global instance structure for the BMP180 sensor driver.
//
//*****************************************************************************
tBMP180 g_sBMP180Inst;

//*****************************************************************************
//
// Global new data flag to alert main that BMP180 data is ready.
//
//*****************************************************************************
volatile uint_fast8_t g_vui8DataFlag;

//*****************************************************************************
//
// The error routine that is called if the driver library encounters an error.
//
//*****************************************************************************
#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif

//*****************************************************************************
//
// BMP180 Sensor callback function.  Called at the end of BMP180 sensor driver
// transactions. This is called from I2C interrupt context. Therefore, we just
// set a flag and let main do the bulk of the computations and display.
//
//*****************************************************************************
void BMP180AppCallback(void* pvCallbackData, uint_fast8_t ui8Status)
{
    if(ui8Status == I2CM_STATUS_SUCCESS)
    {
        g_vui8DataFlag = 1;
    }
}

//*****************************************************************************
//
// Called by the NVIC as a result of I2C3 Interrupt. I2C3 is the I2C connection
// to the BMP180.
//
//*****************************************************************************
void
BMP180I2CIntHandler(void)
{
    //
    // Pass through to the I2CM interrupt handler provided by sensor library.
    // This is required to be at application level so that I2CMIntHandler can
    // receive the instance structure pointer as an argument.
    //
    I2CMIntHandler(&g_sI2CInst);
}

//*****************************************************************************
//
// Called by the NVIC as a SysTick interrupt, which is used to generate the
// sample interval
//
//*****************************************************************************
void
SysTickIntHandler()
{
  //  GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1);
    BMP180DataRead(&g_sBMP180Inst, BMP180AppCallback, &g_sBMP180Inst);
  //  GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0x00);
}

int main(void) {
	
	int  delay;
	float fTemperature, fPressure, fAltitude, fK_Altitude;
	int32_t i32IntegerPart;
	int32_t i32FractionPart;
	int count,i;
	float f_meas[1000], fAlt_Mean, fAlt_Var;


	// Set the clocking to run directly from the external crystal/oscillator.
	//MAP_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
	//		WRFL_XTAL);
	SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
				WRFL_XTAL);

	//init ports and peripherals
	PortFunctionInit();
	Nokia5110_Init();
	Nokia5110_Clear();


    Nokia5110_DrawFullImage(gears_logo);
    for(delay=0; delay<1000000; delay=delay+1);

    Nokia5110_Clear();
    Nokia5110_SetCursor(3, 1);
    Nokia5110_OutString("WRFL");
    Nokia5110_SetCursor(1, 2);
    Nokia5110_OutString("Prototype");
    Nokia5110_SetCursor(2, 4);
    Nokia5110_OutString("VER 0.1");
    Nokia5110_SetCursor(0, 5);
    Nokia5110_OutString("NightMecanic");
    for(delay=0; delay<1000000; delay=delay+1);
    Nokia5110_Clear();
    //
   // Enable interrupts to the processor.
   //
   MAP_IntMasterEnable();

   //
   // Initialize I2C1 peripheral.
   //
   I2CMInit(&g_sI2CInst, BMP180_I2C_BASE, BMP180_I2C_INT, 0xff, 0xff,
			MAP_SysCtlClockGet());

   //
   // Initialize the BMP180
   //
   BMP180Init(&g_sBMP180Inst, &g_sI2CInst, BMP180_I2C_ADDRESS,
			  BMP180AppCallback, &g_sBMP180Inst);


   //
   // Wait for initialization callback to indicate reset request is complete.
   //
   while(g_vui8DataFlag == 0)
   {
	   //
	   // Wait for I2C Transactions to complete.
	   //
   }

   //
   // Reset the data ready flag
   //
   g_vui8DataFlag = 0;

   //set oversampling to 8x
   g_sBMP180Inst.ui8Mode = 0xC0;

   //Initialize the Kalman filter
   KalmanInit();

   //
   // Enable the system ticks at 10 hz.
   //
   MAP_SysTickPeriodSet(MAP_SysCtlClockGet() / (10 * 3));
   MAP_SysTickIntEnable();
   MAP_SysTickEnable();

  //config done
   count = 0;
   //
   // Begin the data collection and printing.  Loop Forever.
   //
   while(1)
   {
	   //
	   // Read the data from the BMP180 over I2C.  This command starts a
	   // temperature measurement.  Then polls until temperature is ready.
	   // Then automatically starts a pressure measurement and polls for that
	   // to complete. When both measurement are complete and in the local
	   // buffer then the application callback is called from the I2C
	   // interrupt context.  Polling is done on I2C interrupts allowing
	   // processor to continue doing other tasks as needed.
	   //
	   BMP180DataRead(&g_sBMP180Inst, BMP180AppCallback, &g_sBMP180Inst);
	   while(g_vui8DataFlag == 0)
	   {
		   //
		   // Wait for the new data set to be available.
		   //
	   }

	   //
	   // Reset the data ready flag.
	   //
	   g_vui8DataFlag = 0;

	   //
	   // Get a local copy of the latest temperature data in float format.
	   //
	   BMP180DataTemperatureGetFloat(&g_sBMP180Inst, &fTemperature);

	   //
	   // Convert the floats to an integer part and fraction part for easy
	   // print.
	   //
	   i32IntegerPart = (int32_t) fTemperature;
	   i32FractionPart =(int32_t) (fTemperature * 1000.0f);
	   i32FractionPart = i32FractionPart - (i32IntegerPart * 1000);
	   if(i32FractionPart < 0)
	   {
		   i32FractionPart *= -1;
	   }

	   //
	   // Print temperature with three digits of decimal precision.
	   //
	   //UARTprintf("Temperature %3d.%03d\t\t", i32IntegerPart, i32FractionPart);
	   Nokia5110_SetCursor(0, 0);
	       Nokia5110_OutString("Temp:");
	       Nokia5110_OutUDec_NoSpace((unsigned short)i32IntegerPart);
	       Nokia5110_OutString(".");
	       Nokia5110_OutUDec_NoSpace((unsigned short)i32FractionPart);

	   //
	   // Get a local copy of the latest air pressure data in float format.
	   //
	   BMP180DataPressureGetFloat(&g_sBMP180Inst, &fPressure);



	   //
	   // Convert the floats to an integer part and fraction part for easy
	   // print.
	   //display in hPa

	   i32IntegerPart = (int32_t) (fPressure / 100.0f);
	   i32FractionPart =(int32_t) (fPressure * 10.0f);
	   i32FractionPart = i32FractionPart - (i32IntegerPart * 1000);
	   if(i32FractionPart < 0)
	   {
		   i32FractionPart *= -1;
	   }

	   //
	   // Print Pressure with three digits of decimal precision.
	   //
	   //UARTprintf("Pressure %3d.%03d\t\t", i32IntegerPart, i32FractionPart);
	   Nokia5110_SetCursor(0, 1);
	   Nokia5110_OutString("Pres:");
	   Nokia5110_SetCursor(0, 2);
	   Nokia5110_OutUDec_NoSpace((unsigned short)i32IntegerPart);
	   Nokia5110_OutString(".");
	   Nokia5110_OutUDec_NoSpace((unsigned short)i32FractionPart);

	   //
	   // Calculate the altitude.
	   //
	   //fAltitude = 44330.0f * (1.0f - powf(fPressure / 101325.0f,
	//									   1.0f / 5.255f));
	   //corrected:
	   fAltitude = 44330.0f * (1.0f - powf(fPressure / LOC_ALT_P0,
	   										   1.0f / 5.255f));

	   //
	   // Convert the floats to an integer part and fraction part for easy
	   // print.
	   //
	   i32IntegerPart = (int32_t) fAltitude;
	   i32FractionPart =(int32_t) (fAltitude * 1000.0f);
	   i32FractionPart = i32FractionPart - (i32IntegerPart * 1000);
	   if(i32FractionPart < 0)
	   {
		   i32FractionPart *= -1;
	   }

	   //
	   // Print altitude with three digits of decimal precision.
	   //
	   //UARTprintf("Altitude %3d.%03d", i32IntegerPart, i32FractionPart);
	   Nokia5110_SetCursor(0, 3);
	   Nokia5110_OutString("Var:");
	   if(i32IntegerPart<0)
	   {
		   Nokia5110_OutString("-");
		   i32IntegerPart *= -1;
	   }
	   Nokia5110_OutUDec_NoSpace((unsigned short)i32IntegerPart);
	   Nokia5110_OutString(".");
	   Nokia5110_OutUDec_NoSpace((unsigned short)i32FractionPart);

	   //calculate variance
	   f_meas[count]=fAltitude;
	   count++;

	   if (count>=1000){
		   fAlt_Mean = 0;
		   fAlt_Var = 0;
		   // calculate mean
		   for(i=0; i<1000; i++){
			   fAlt_Mean = fAlt_Mean +f_meas[i];
		   }
		   // Calculate Var
		   for(i=0; i<1000; i++){
		   			   fAlt_Var = fAlt_Var + (sqrtf(f_meas[i] - fAlt_Mean));
		   		   }
		   fAlt_Var = fAlt_Var/1000.0f;

		   //
		   	   // Convert the floats to an integer part and fraction part for easy
		   	   // print.
		   	   //
		   	   i32IntegerPart = (int32_t) fAlt_Var;
		   	   i32FractionPart =(int32_t) (fAlt_Var * 1000.0f);
		   	   i32FractionPart = i32FractionPart - (i32IntegerPart * 1000);
		   	   if(i32FractionPart < 0)
		   	   {
		   		   i32FractionPart *= -1;
		   	   }

		   	   //
		   	   // Print altitude with three digits of decimal precision.
		   	   //
		   	   //UARTprintf("Altitude %3d.%03d", i32IntegerPart, i32FractionPart);
		   	   Nokia5110_SetCursor(0, 4);
		   	   Nokia5110_OutString("Alt:");
		   	   if(i32IntegerPart<0)
		   	   {
		   		   Nokia5110_OutString("-");
		   		   i32IntegerPart *= -1;
		   	   }
		   	   Nokia5110_OutUDec_NoSpace((unsigned short)i32IntegerPart);
		   	   Nokia5110_OutString(".");
		   	   Nokia5110_OutUDec_NoSpace((unsigned short)i32FractionPart);

		   count = 0;

	   }

	   // Print Kalman filtered altitude

	   fK_Altitude = KalmanCalc (fAltitude);

	   //
	  	   // Convert the floats to an integer part and fraction part for easy
	  	   // print.
	  	   //
	  	   i32IntegerPart = (int32_t) fK_Altitude;
	  	   i32FractionPart =(int32_t) (fK_Altitude * 1000.0f);
	  	   i32FractionPart = i32FractionPart - (i32IntegerPart * 1000);
	  	   if(i32FractionPart < 0)
	  	   {
	  		   i32FractionPart *= -1;
	  	   }

	  	   //
	  	   // Print altitude with three digits of decimal precision.
	  	   //
	  	   //UARTprintf("Altitude %3d.%03d", i32IntegerPart, i32FractionPart);
	  	   Nokia5110_SetCursor(0, 5);
	  	   Nokia5110_OutString("KAlt:");
	  	   if(i32IntegerPart<0)
	  	   {
	  		   Nokia5110_OutString("-");
	  		   i32IntegerPart *= -1;
	  	   }
	  	   Nokia5110_OutUDec_NoSpace((unsigned short)i32IntegerPart);
	  	   Nokia5110_OutString(".");
	  	   Nokia5110_OutUDec_NoSpace((unsigned short)i32FractionPart);


	   //
	   // Delay to keep printing speed reasonable. About 1sec.
	   //
	   MAP_SysCtlDelay(MAP_SysCtlClockGet() / (10 * 3));
//	   for(delay=0; delay<1000000; delay=delay+1);

   }//while end
}

